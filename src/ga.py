import numpy as np
import copy
import pandas as pd

# Genetic Algorithm base class for the Knapsack problem. This can be refactored to be extensible for different optimization problems.
class GA():
    def __init__(self, population_size, 
                 generations, profits, weights, capacity,
                 mutation_rate=0.1,
                 items=10, mating_pool_size=5,
                 population=None):
        self.population_size = population_size
        self.generations = generations
        self.profits = profits
        self.weights = weights
        self.capacity = capacity
        self.mutation_rate = mutation_rate
        self.items = items
        self.mating_pool_size = mating_pool_size
        self.population = self.generate_population() if population is None else population

    def get_fitness(self, solution):
        """
        Knapsack fitness function
        """
        weight = sum(included * weight for included, weight in zip(solution, self.weights))
        profit = sum(included * profit for included, profit in zip(solution, self.profits)) 

        # not feasible
        if weight > self.capacity:
            return 0
        return profit
    
    def get_population_fitness(self, population):
        """
        Get the population fitness as an array
        """
        return np.array([self.get_fitness(solution) for solution in population])
    
    def get_initial_solution(self) -> list:
        """
        Generate a random initial solution. If a feasible solution is not found after 20 attempts, return an empty knapsack.
        """
        for i in range(20):
            solution = np.random.randint(2, size=self.items)
            # need to make sure initial solution is feasible
            if self.get_fitness(solution) > 0:
                return solution
        # if we can't generate a random initial solution, set to empty knapsack
        return [0] * self.items

    def generate_population(self):
        """
        Generate an initial population
        """
        return [self.get_initial_solution() for _ in range(self.population_size)]
    
    def roulette_wheel_selection(self, population):
        """
        Apply selection based on normalized fitness values
        """
        fitness_array = self.get_population_fitness(population)
        total_fitness = np.sum(fitness_array)
        probabilities = fitness_array / total_fitness

        try:
            indices = np.random.choice(len(fitness_array), self.mating_pool_size, replace=False, p=probabilities)
        except ValueError:
            print("Fewer non-zero entries in p than size - select mating pool at random")
            indices = np.random.choice(len(fitness_array), self.mating_pool_size, replace=False)
        mating_pool = np.array([population[i] for i in indices])
        return mating_pool
    
    def tournament_selection(self, population):
        """
        Select the best individuals from a random subset
        """
        tournament_size = len(population) // 5
        tournament = np.random.choice(population, tournament_size)
        # Return the best solution from the tournament
        return max(tournament, key=self.get_fitness)

    def repair_solution(self, solution):
        """
        Repair a solution to ensure it is feasible. Use a greedy approach to remove items from the solution until it is feasible.
        """
        total_weight = sum([self.weights[i] for i in range(len(solution)) if solution[i] == 1])
        if total_weight <= self.capacity:
            return solution
        
        # get profit to weight ratio for each item in the solution
        profit_weight_ratio = [profit/weight for profit, weight in zip(self.profits, self.weights)]
        sorted_items = sorted(enumerate(profit_weight_ratio), key=lambda x: x[1])

        # remove items from the solution until it is feasible
        for item in sorted_items:
            if total_weight <= self.capacity:
                break
            solution[item[0]] = 0
            total_weight -= self.weights[item[0]]
    
        return solution
    

    def crossover(self, parent_1, parent_2):
        """
        Random crossover point is selected and the offspring is generated by swapping the tails of the parents
        """
        n = len(parent_1)

        crossover_point = np.random.randint(1, n)

        offspring_1 = [*parent_1[:crossover_point], *parent_2[crossover_point:]]
        offspring_2 = [*parent_2[:crossover_point], *parent_1[crossover_point:]]

        feasible_1 = self.repair_solution(offspring_1)
        feasible_2 = self.repair_solution(offspring_2)
        return feasible_1, feasible_2

    def mutation(self, solution):
        """
        Mutate the solution by flipping a random bit with a probability of mutation_rate
        """
        neighbor = copy.deepcopy(solution)
        index = np.random.randint(self.items, size=1)
        index = index[0]
        # remove or exclude the item in the candidate solution
        try:
            neighbor[index] = 1 - neighbor[index]
        except:
            print()
            # print(neighbor)
        return self.repair_solution(neighbor)
    
# Steady State GA
class StandardGA(GA):
    def __init__(self, population_size, 
                 generations, profits, weights, capacity,
                 mutation_rate=0.01, items=10, mating_pool_size=5,
                 population=None):
        super().__init__(population_size, generations, profits, 
                         weights, capacity, mutation_rate=mutation_rate, items=items, 
                            mating_pool_size=mating_pool_size, population=population)

    def run(self):
        fitness_results = []
        population_df = pd.DataFrame({"generation": 0, "solution": self.population, "fitness": self.get_population_fitness(self.population)})
        for generation in range(self.generations):
            self.ran_simulated_annealing = 0
            # perform selection
            mating_pool = self.roulette_wheel_selection(population_df['solution'])
            # random selection of parents from mating pool
            parents = mating_pool[np.random.choice(len(mating_pool), 2, replace=False)]
            parent_1, parent_2 = parents

            offspring_1, offspring_2 = self.crossover(parent_1, parent_2)
            offspring_1 = self.mutation(offspring_1)
            offspring_2 = self.mutation(offspring_2)
            offspring_1 = self.repair_solution(offspring_1)
            offspring_2 = self.repair_solution(offspring_2)

            # update the population, sort by the lowest fitness
            population_df = population_df.sort_values(by='fitness', ascending=True)
            population_df = population_df.iloc[2:]

            offspring_df = pd.DataFrame({"generation": generation, "solution": [offspring_1, offspring_2], "fitness": [self.get_fitness(offspring_1), self.get_fitness(offspring_2)]})
            population_df = pd.concat([offspring_df, population_df], ignore_index=True)
            fitness_results.append({"generation": generation, "fitness": population_df['fitness'].max(), "algorithm": 'ga'})

        return population_df, pd.DataFrame(fitness_results)

if __name__ == "__main__":
    pass